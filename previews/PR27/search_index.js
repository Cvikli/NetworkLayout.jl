var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NetworkLayout","category":"page"},{"location":"#NetworkLayout","page":"Home","title":"NetworkLayout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the Documentation for NetworkLayout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All example images on this page are created using Makie.jl and the graphplot recipe from GraphMakie.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") # hide\nset_theme!(resolution=(800, 400)) #hide\nCairoMakie.inline!(true) # hide\nusing NetworkLayout\nusing GraphMakie, LightGraphs, LightGraphs\nimport Random; Random.seed!(2) # hide\nnothing #hide","category":"page"},{"location":"#Basic-Usage-and-Algorithms","page":"Home","title":"Basic Usage & Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of the algorithms follow the layout interface. Each layout algorithm is represented by a type Algorithm <: AbstractLayout. The parameters of each algorithm can be set with keyword arguments. The Algorithm object itself is callable and transforms the adjacency matrix and returns a list of Point{N,T} from GeometryBasics.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"alg = Algorithm(; p1=\"foo\", p2=:bar)\npositions = alg(adj_matrix)","category":"page"},{"location":"#Scalable-Force-Directed-Placement","page":"Home","title":"Scalable Force Directed Placement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SFDP","category":"page"},{"location":"#NetworkLayout.SFDP","page":"Home","title":"NetworkLayout.SFDP","text":"SFDP(; kwargs...)(adj_matrix)\nlayout(algo::SFDP, adj_matrix)\n\nUsing the Spring-Electric model suggested by Yifan Hu. Forces are calculated as:\n\n    f_attr(i,j) = ‖xi - xj‖ ² / K ,    i<->j\n    f_repln(i,j) = -CK² / ‖xi - xj‖ ,  i!=j\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\ntol=1.0: Stop if position changes of last step Δp <= tol*K for all nodes\nC=0.2, K=1.0: Parameters to tweak forces.\niterations=100: maximum number of iterations\ninitialpos=Point{dim,Ptype}[]\nProvide list of initial positions. If length does not match Network size the initial positions will be truncated or filled up with random values between [-1,1] in every coordinate.\n\n\n\n\n\n","category":"type"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: SFDP\ng = wheel_graph(10)\nlayout = SFDP(tol=0.01, C=0.2, K=1)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Buchheim-Tree-Drawing","page":"Home","title":"Buchheim Tree Drawing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Buchheim","category":"page"},{"location":"#NetworkLayout.Buchheim","page":"Home","title":"NetworkLayout.Buchheim","text":"Buchheim(; kwargs...)(adj_matrix)\nBuchheim(; kwargs...)(adj_list)\nlayout(algo::Buchheim, adj_matrix)\nlayout(algo::Buchheim, adj_list)\n\nUsing the algorithm proposed in the paper, \"Improving Walker's Algorithm to Run in Linear Time\" by Christoph Buchheim, Michael Junger, Sebastian Leipert\n\nTakes adjacency matrix or list representation of given tree and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}.\nnodesize=Float64[]\nDetermines the size of each of the node. If network size does not match the length of nodesize fill up with ones or truncate given parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Example-2","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Buchheim\n\nadj_matrix = [0 1 1 0 0 0 0 0 0 0;\n\n              0 0 0 0 1 1 0 0 0 0;\n              0 0 0 1 0 0 1 0 1 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 1 0 1;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0]\ng = SimpleDiGraph(adj_matrix)\nlayout = Buchheim()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spring/Repulsion-Model","page":"Home","title":"Spring/Repulsion Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spring","category":"page"},{"location":"#NetworkLayout.Spring","page":"Home","title":"NetworkLayout.Spring","text":"Spring(; kwargs...)(adj_matrix)\nlayout(algo::Spring, adj_matrix)\n\nUse the spring/repulsion model of Fruchterman and Reingold (1991) with\n\nAttractive force:  f_a(d) =  d^2 / k\nRepulsive force:  f_r(d) = -k^2 / d\n\nwhere d is distance between two vertices and the optimal distance between vertices k is defined as C * sqrt( area / num_vertices ) where C is a parameter we can adjust\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\nC=2.0: Constant to fiddle with density of resulting layout\niterations=100: maximum number of iterations\ninitialtemp=2.0: Initial \"temperature\", controls movement per iteration\ninitialpos=Point{dim,Ptype}[]\nProvide list of initial positions. If length does not match Network size the initial positions will be truncated or filled up with random values between [-1,1] in every coordinate.\n\n\n\n\n\n","category":"type"},{"location":"#Example-3","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Spring\ng = smallgraph(:cubical)\nlayout = Spring()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Stress-Majorization","page":"Home","title":"Stress Majorization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stress","category":"page"},{"location":"#NetworkLayout.Stress","page":"Home","title":"NetworkLayout.Stress","text":"Stress(; kwargs...)(adj_matrix)\nlayout(algo::Stress, adj_matrix)\n\nCompute graph layout using stress majorization. Takes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nInputs:\n\nadj_matrix: Matrix of pairwise distances.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\niterations=:auto: maximum number of iterations (:auto means 400*N^2 where N are the number of vertices)\nabstols=(√(eps(Float64)))\nAbsolute tolerance for convergence of stress. The iterations terminate if the  difference between two successive stresses is less than abstol.\nreltols=(√(eps(Float64)))\nRelative tolerance for convergence of stress. The iterations terminate if the difference between two successive stresses relative to the current stress is less than reltol.\nabstolx=(√(eps(Float64)))\nAbsolute tolerance for convergence of layout. The iterations terminate if the Frobenius norm of two successive layouts is less than abstolx.\nweights=Array{Float64}(undef, 0, 0)\nMatrix of weights. If empty (i.e. not specified), defaults to weights[i,j] = δ[i,j]^-2 if δ[i,j] is nonzero, or 0 otherwise.\ninitialpos=Point{dim,Ptype}[]\nProvide list of initial positions. If length does not match Network size the initial positions will be truncated or filled up with random normal distributed values in every coordinate.\n\nReference:\n\nThe main equation to solve is (8) of:\n\n@incollection{\n    author = {Emden R Gansner and Yehuda Koren and Stephen North},\n    title = {Graph Drawing by Stress Majorization}\n    year={2005},\n    isbn={978-3-540-24528-5},\n    booktitle={Graph Drawing},\n    seriesvolume={3383},\n    series={Lecture Notes in Computer Science},\n    editor={Pach, J'anos},\n    doi={10.1007/978-3-540-31843-9_25},\n    publisher={Springer Berlin Heidelberg},\n    pages={239--250},\n}\n\n\n\n\n\n","category":"type"},{"location":"#Example-4","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Stress\ng = complete_graph(10)\nlayout = Stress()\nRandom.seed!(1)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide\n","category":"page"},{"location":"#Circular-Layout","page":"Home","title":"Circular Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Circular","category":"page"},{"location":"#NetworkLayout.Circular","page":"Home","title":"NetworkLayout.Circular","text":"Circular(; kwargs...)(adj_matrix)\nlayout(algo::Circular, adj_matrix)\n\nPosition nodes on a circle with radius 1.\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Circular\ng = smallgraph(:karate)\nlayout = Circular()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Shell-Layout","page":"Home","title":"Shell Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shell","category":"page"},{"location":"#NetworkLayout.Shell","page":"Home","title":"NetworkLayout.Shell","text":"Shell(; kwargs...)(adj_matrix)\nlayout(algo::Shell, adj_matrix)\n\nPosition nodes in conenctric circles.\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}.\nnlist=Vector{Int}[]\nList of node-lists for each shell from inner to outer. Tells the algorithm which node idx to place on which circle. Nodes which are not present in this list will be place on additional outermost shell.\n\nThis function started as a copy from IainNZ's GraphLayout.jl\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Shell\ng = smallgraph(:petersen)\nlayout = Shell(nlist=[6:10,])\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spectral","page":"Home","title":"Spectral","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral needs 3d which isn't ready yet on the GraphMakie side.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JSServe\nPage(exportable=true, offline=true)\nusing WGLMakie #hide\nWGLMakie.activate!() # hide\nset_theme!(resolution=(800, 400)) # hide\nscatter([1,2,3], [1,2,3])","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = smallgraph(:petersen)\nlayout = Shell(nlist=[6:10,])\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"}]
}
