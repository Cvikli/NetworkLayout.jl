var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NetworkLayout","category":"page"},{"location":"#NetworkLayout","page":"Home","title":"NetworkLayout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the Documentation for NetworkLayout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All example images on this page are created using Makie.jl and the graphplot recipe from GraphMakie.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") # hide\nset_theme!(resolution=(800, 400)) #hide\nAbstractPlotting.inline!(true) # hide\nusing NetworkLayout\nusing GraphMakie, LightGraphs, LightGraphs\nimport Random; Random.seed!(2) # hide\nset_theme!(scatter_theme, color = :red) # hide\nnothing #hide","category":"page"},{"location":"#Basic-Usage-and-Algorithms","page":"Home","title":"Basic Usage & Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of the algorithms follow the layout interface. Each layout algorithm is represented by a type Algorithm <: AbstractLayout. The parameters of each algorithm can be set with keyword arguments. The Algorithm object itself is callable and transforms the adjacency matrix and returns a list of Point{N,T} from GeometryBasics.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"alg = Algorithm(; p1=\"foo\", p2=:bar)\npositions = alg(adj_matrix)","category":"page"},{"location":"#Scalable-Force-Directed-Placement","page":"Home","title":"Scalable Force Directed Placement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SFDP","category":"page"},{"location":"#NetworkLayout.SFDP","page":"Home","title":"NetworkLayout.SFDP","text":"Using the Spring-Electric model suggested by Yifan Hu (http://yifanhu.net/PUB/graphdrawsmall.pdf) Forces are calculated as :         fattr(i,j) = ||xi - xj||^2 / K ,     i<->j         frepln(i,j) = -CK^2 / ||xi - xj|| ,  i!=j Arguments :   adj_matrix      Sparse/Full Adjacency matrix of the graph   tol             Tolerance distance - Minimum distance between 2 nodes   C, K            Constants that help scale the layout Output :   positions       Co-ordinates for the nodes\n\n\n\n\n\n","category":"type"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: SFDP\ng = wheel_graph(10)\nlayout = SFDP(tol=0.01, C=0.2, K=1)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Buchheim-Tree-Drawing","page":"Home","title":"Buchheim Tree Drawing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Buchheim","category":"page"},{"location":"#Example-2","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Buchheim\n\nadj_matrix = [0 1 1 0 0 0 0 0 0 0;\n\n              0 0 0 0 1 1 0 0 0 0;\n              0 0 0 1 0 0 1 0 1 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 1 0 1;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0]\ng = SimpleDiGraph(adj_matrix)\nlayout = Buchheim()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spring/Repulsion-Model","page":"Home","title":"Spring/Repulsion Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spring","category":"page"},{"location":"#NetworkLayout.Spring","page":"Home","title":"NetworkLayout.Spring","text":"Use the spring/repulsion model of Fruchterman and Reingold (1991):\n    Attractive force:  f_a(d) =  d^2 / k\n    Repulsive force:  f_r(d) = -k^2 / d\nwhere d is distance between two vertices and the optimal distance\nbetween vertices k is defined as C * sqrt( area / num_vertices )\nwhere C is a parameter we can adjust\n\nArguments:\nadj_matrix    Adjacency matrix of some type. Non-zero of the eltype\n              of the matrix is used to determine if a link exists,\n              but currently no sense of magnitude\nC             Constant to fiddle with density of resulting layout\niterations    Number of iterations we apply the forces\ninitialtemp   Initial \"temperature\", controls movement per iteration\n\n\n\n\n\n","category":"type"},{"location":"#Example-3","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Spring\ng = smallgraph(:cubical)\nlayout = Spring()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Stress-Majorization","page":"Home","title":"Stress Majorization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stress","category":"page"},{"location":"#NetworkLayout.Stress","page":"Home","title":"NetworkLayout.Stress","text":"Compute graph layout using stress majorization\n\nInputs:\n\nδ: Matrix of pairwise distances\np: Dimension of embedding (default: 2)\nweights: Matrix of weights. If not specified, defaults to\n       weights[i,j] = δ[i,j]^-2 if δ[i,j] is nonzero, or 0 otherwise\nX0: Initial guess for the layout. Coordinates are given in rows.\n    If not specified, default to random matrix of Gaussians\n\nAdditional optional keyword arguments control the convergence of the algorithm and the additional output as requested:\n\niterations:   Maximum number of iterations. Default: 400size(X0, 1)^2\nabstols:      Absolute tolerance for convergence of stress.\n              The iterations terminate if the difference between two\n              successive stresses is less than abstol.\n              Default: √(eps(eltype(X0))\nreltols:      Relative tolerance for convergence of stress.\n              The iterations terminate if the difference between two\n              successive stresses relative to the current stress is less than\n              reltol. Default: √(eps(eltype(X0))\nabstolx:      Absolute tolerance for convergence of layout.\n              The iterations terminate if the Frobenius norm of two successive\n              layouts is less than abstolx. Default: √(eps(eltype(X0))\n\nOutput:\n\nThe final layout positions.\n\nReference:\n\nThe main equation to solve is (8) of:\n\n@incollection{\n    author = {Emden R Gansner and Yehuda Koren and Stephen North},\n    title = {Graph Drawing by Stress Majorization}\n    year={2005},\n    isbn={978-3-540-24528-5},\n    booktitle={Graph Drawing},\n    seriesvolume={3383},\n    series={Lecture Notes in Computer Science},\n    editor={Pach, J'anos},\n    doi={10.1007/978-3-540-31843-9_25},\n    publisher={Springer Berlin Heidelberg},\n    pages={239--250},\n}\n\n\n\n\n\n","category":"type"},{"location":"#Example-4","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Stress\ng = complete_graph(10)\nlayout = Stress()\nRandom.seed!(1)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide\n","category":"page"},{"location":"#Circular-Layout","page":"Home","title":"Circular Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Circular","category":"page"},{"location":"#NetworkLayout.Circular","page":"Home","title":"NetworkLayout.Circular","text":"This function wrap from NetworkX Position nodes on a circle. Parameters adj_matrix a graph Returns locsx, locsy Locations of the nodes. Can be any units you want, but will be normalized and centered anyway Examples\n\njulia> g = simple_house_graph()\njulia> locs_x, locs_y = circular_layout(g)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Circular\ng = smallgraph(:karate)\nlayout = Circular()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Shell-Layout","page":"Home","title":"Shell Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shell","category":"page"},{"location":"#NetworkLayout.Shell","page":"Home","title":"NetworkLayout.Shell","text":"This function is copy from IainNZ's GraphLayout.jl Position nodes in concentric circles. Parameters adj_matrix a graph nlist Vector of Vector, Vector of node Vector for each shell. Examples\n\njulia> g = graphfamous(\"karate\")\njulia> nlist = Array(Vector{Int}, 2)\njulia> nlist[1] = [1:5]\njulia> nlist[2] = [6:num_vertiecs(g)]\njulia> locs_x, locs_y = shell_layout(g, nlist)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"using NetworkLayout: Shell\ng = smallgraph(:petersen)\nlayout = Shell(nlist=[6:10,])\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spectral","page":"Home","title":"Spectral","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral needs 3d which isn't ready yet on the GraphMakie side.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JSServe\nPage(exportable=true, offline=true)\nusing WGLMakie #hide\nWGLMakie.activate!() # hide\nset_theme!(resolution=(800, 400)) # hide\nscatter([1,2,3], [1,2,3])","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = smallgraph(:petersen)\nlayout = Shell(nlist=[6:10,])\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"}]
}
